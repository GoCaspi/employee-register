package handler

import (
	"crypto/subtle"
	"example-project/cache"
	"example-project/model"
	"example-project/utility"
	"github.com/gin-gonic/gin"
	//	"go.mongodb.org/mongo-driver/x/mongo/driver/uuid"
	"github.com/google/uuid"
	"net/http"
)

//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . ServiceInterface
type ServiceInterface interface {
	CreateEmployees(employees []model.Employee) (interface{}, error)
	GetEmployeeById(id string) model.Employee
	DeleteEmployee(id string) (interface{}, error)
}

var MyCacheMap = cache.NewCacheMap{}

const noTokenErr = "No token is provided. Please login in and provide a token"
const noEmployeeFound = "Cannot find an employee to that id!"
const invalidPayloadMsg = "invalid payload"

type Handler struct {
	ServiceInterface ServiceInterface
}

func NewHandler(serviceInterface ServiceInterface) Handler {
	return Handler{
		ServiceInterface: serviceInterface,
	}
}

func (handler Handler) CreateEmployeeHandler(c *gin.Context) {
	var payLoad model.Payload
	err := c.ShouldBindJSON(&payLoad)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
			"errorMessage": "invalid payload",
		})
		return
	}

	employees := payLoad.Employees
	hashedEmployees := utility.HashEmployees(employees)
	index, _ := handler.DoUserExist(hashedEmployees)
	if index {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
			"errorMessage": "There cannot be duplicated Ids!",
		})
		return
	}
	response, err := handler.ServiceInterface.CreateEmployees(hashedEmployees)

	c.JSON(200, response)
}

func (handler Handler) GetEmployeeHandler(c *gin.Context) {
	pathParam, ok := c.Params.Get("id")
	if !ok {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
			"errorMessage": "id is not given",
		})
		return
	}

	response := handler.ServiceInterface.GetEmployeeById(pathParam)
	c.JSON(http.StatusOK, response)
}

func (handler Handler) Login(c *gin.Context) {
	// Reads the id from the employee that wants to Login from the query parameter. example : /employees/Login?id=1
	// and finds the employee in the database
	id, keyIsPresent := c.GetQuery("id")
	errMsg := noEmployeeFound
	if !keyIsPresent {
		c.AbortWithStatusJSON(400, errMsg)
		return
	}
	employee := handler.ServiceInterface.GetEmployeeById(id)
	//	if err != nil {
	//		c.AbortWithStatusJSON(400, noEmployeeFound)
	//		return
	//	}
	// Auth is the struct of authentification. It has a username and a password. The Auth struct needs to be posted to the endpoint (Login)
	var payLoad model.Auth
	err := c.ShouldBindJSON(&payLoad)
	errMsg = invalidPayloadMsg
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, errMsg)
		return
	}
	if err == nil {

		actualUser, actualPwd := utility.HashUsernameAndPassword(payLoad).Username, utility.HashUsernameAndPassword(payLoad).Password
		validUser, validPwd := employee.Auth.Username, employee.Auth.Password

		// compare expected and actual. If Match !=1 comparison failed
		usernameMatch := subtle.ConstantTimeCompare(actualUser[:], validUser[:]) == 1
		passwordMatch := subtle.ConstantTimeCompare(actualPwd[:], validPwd[:]) == 1

		// if authoraziton successfull return a new token (generated by google/uuid)
		// which can be used as Barer token for accessing all /employee endpoints
		if usernameMatch && passwordMatch {
			uuid := uuid.New()
			uuidString := uuid.String()
			successMsg := "Success! Your Token is: " + uuidString
			// add the new Token to the cache
			MyCacheMap = cache.AddToCacheMap(employee.ID, uuidString, MyCacheMap)

			c.JSON(http.StatusOK, successMsg)
			return
		}
	}
	// if authorization check fails restrict the endpoint from usage
	errMsg = "The username or password is wrong"
	c.AbortWithStatusJSON(401, errMsg)
	c.Writer.Header().Set("WWW-Authenticate", `Basic realm="restricted", charset="UTF-8"`)
	return
}

func (handler Handler) DoUserExist(emp []model.Employee) (bool, []model.Employee) {
	var idList []string
	var errorEmployees []model.Employee

	for _, employee := range emp {
		response := handler.ServiceInterface.GetEmployeeById(employee.ID)
		if len(response.ID) != 0 {
			errorEmployees = append(errorEmployees, employee)
		} else {
			idList = append(idList, employee.ID)
			var idCount int = 0
			for _, id := range idList {
				if id == employee.ID {
					idCount++
				}
			}
			if idCount >= 2 {
				errorEmployees = append(errorEmployees, employee)
			}
		}
	}
	if len(errorEmployees) != 0 {
		return true, errorEmployees
	} else {
		return false, nil
	}
}

// TokenCheck validates if a valid token was submitted
func (handler Handler) ValidateToken(c *gin.Context) {

	// if no Baerer Token is provided Abort with error message
	if len(c.Request.Header.Values("Authorization")) < 1 {
		c.AbortWithStatusJSON(403, noTokenErr)
		return
	}
	// read the value of the baerer token

	reqToken := utility.GetBearerToken(c)

	// check if the provided token is in cache. If the token is not in cache abort with error message
	tokenIsValid := cache.TokenIsInMap(reqToken, MyCacheMap)
	//	tokenIsValid := myCache.CheckIfTokenIsInCache(reqToken)
	if !tokenIsValid {
		c.AbortWithStatusJSON(401, noTokenErr)

	} else {
		return
	}
}

func (handler Handler) Logout(c *gin.Context) {
	// reads the id from the query parameters
	id, keyIsPresent := c.GetQuery("id")
	errMsg := noEmployeeFound
	if !keyIsPresent {
		c.AbortWithStatusJSON(400, errMsg)
		return
	}
	// checks if the provided token is in cache (meaning its a valid token)
	tokenIsInCache := cache.IdIsInMap(id, MyCacheMap)
	successMessage := "Logut successfull. Your token is no longer valid."
	failMessage := "The provided token is not valid. Please login to generate a valid token."

	if tokenIsInCache {
		MyCacheMap = cache.RemoveFromCacheMap(id, MyCacheMap)
		c.JSON(200, successMessage)
	} else {
		c.JSON(400, failMessage)
	}
}

func (handler Handler) DeleteByIdHandler(c *gin.Context) {
	pathParam, ok := c.Params.Get("id")

	if !ok {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{

			"errorMessage": "id is not found",
		})
		return
	}
	response, err := handler.ServiceInterface.DeleteEmployee(pathParam)

	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
			"errorMessage": err.Error(),
		})
		return
	}
	c.JSON(http.StatusOK, response)
}
