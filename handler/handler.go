package handler

import (
	"crypto/subtle"
	"example-project/cache"
	"example-project/model"
	"example-project/utility"
	"github.com/gin-gonic/gin"
	//	"go.mongodb.org/mongo-driver/x/mongo/driver/uuid"
	"github.com/google/uuid"
	"net/http"
)

//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . ServiceInterface
type ServiceInterface interface {
	CreateEmployees(employees []model.Employee) (interface{}, error)
	GetEmployeeById(id string) model.Employee
}

var MyCacheMap = cache.NewCacheMap{}

const noTokenErr = "No token is provided. Please login in and provide a token"
const noEmployeeFound = "Cannot find an employee to that id!"
const invalidPayloadMsg = "invalid payload"

type Handler struct {
	ServiceInterface ServiceInterface
}

func NewHandler(serviceInterface ServiceInterface) Handler {
	return Handler{
		ServiceInterface: serviceInterface,
	}
}

func (handler Handler) CreateEmployeeHandler(c *gin.Context) {
	var payLoad model.Payload
	err := c.ShouldBindJSON(&payLoad)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
			"errorMessage": "invalid payload",
		})
		return
	}

	employees := payLoad.Employees
	hashedEmployees := utility.HashEmployees(employees)

	response, err := handler.ServiceInterface.CreateEmployees(hashedEmployees)

	c.JSON(200, response)
}

func (handler Handler) GetEmployeeHandler(c *gin.Context) {
	pathParam, ok := c.Params.Get("id")
	if !ok {
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{
			"errorMessage": "id is not given",
		})
		return
	}

	response := handler.ServiceInterface.GetEmployeeById(pathParam)
	c.JSON(http.StatusOK, response)
}

func (handler Handler) Login(c *gin.Context) {
	// Reads the id from the employee that wants to Login from the query parameter. example : /employees/Login?id=1
	// and finds the employee in the database
	id, keyIsPresent := c.GetQuery("id")
	errMsg := noEmployeeFound
	if !keyIsPresent {
		c.AbortWithStatusJSON(400, errMsg)
		return
	}
	employee := handler.ServiceInterface.GetEmployeeById(id)
	//	if err != nil {
	//		c.AbortWithStatusJSON(400, noEmployeeFound)
	//		return
	//	}
	// Auth is the struct of authentification. It has a username and a password. The Auth struct needs to be posted to the endpoint (Login)
	var payLoad model.Auth
	err := c.ShouldBindJSON(&payLoad)
	errMsg = invalidPayloadMsg
	if err != nil {
		c.AbortWithStatusJSON(http.StatusBadRequest, errMsg)
		return
	}
	if err == nil {

		actualUser, actualPwd := utility.HashUsernameAndPassword(payLoad).Username, utility.HashUsernameAndPassword(payLoad).Password
		validUser, validPwd := employee.Auth.Username, employee.Auth.Password

		// compare expected and actual. If Match !=1 comparison failed
		usernameMatch := subtle.ConstantTimeCompare(actualUser[:], validUser[:]) == 1
		passwordMatch := subtle.ConstantTimeCompare(actualPwd[:], validPwd[:]) == 1

		// if authoraziton successfull return a new token (generated by google/uuid)
		// which can be used as Barer token for accessing all /employee endpoints
		if usernameMatch && passwordMatch {
			uuid := uuid.New()
			uuidString := uuid.String()
			successMsg := "Success! Your Token is: " + uuidString
			// add the new Token to the cache
			MyCacheMap = cache.AddToCacheMap(employee.ID, uuidString, MyCacheMap)

			c.JSON(http.StatusOK, successMsg)
			return
		}
	}
	// if authorization check fails restrict the endpoint from usage
	errMsg = "The username or password is wrong"
	c.AbortWithStatusJSON(401, errMsg)
	c.Writer.Header().Set("WWW-Authenticate", `Basic realm="restricted", charset="UTF-8"`)
	return
}
